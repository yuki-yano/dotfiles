#!/usr/bin/env -S deno run --allow-run --allow-env --allow-read

import { Command } from "jsr:@cliffy/command@1.0.0-rc.7";
import { colors } from "jsr:@cliffy/ansi@1.0.0-rc.4";
import { $, CommandBuilder } from "jsr:@david/dax@0.44.0";
import { fromFileUrl } from "jsr:@std/path@1.1.3";

const decoder = new TextDecoder();
const encoder = new TextEncoder();

type Action = "session" | "window" | "create" | "server";

type WindowInfo = {
  index: string;
  name: string;
  panes: number;
  active: boolean;
  command: string;
};

type SessionInfo = {
  name: string;
  windows: WindowInfo[];
  totalWindows: number;
  totalPanes: number;
  isCurrent: boolean;
};

type Entry = {
  action: Action;
  name: string;
  display: string;
};

type RunCommandOptions = {
  allowFail?: boolean;
  inheritStdio?: boolean;
};

type PaneInfo = {
  id: string;
  pid: string;
};

async function runCommand(
  cmd: string,
  args: string[],
  { allowFail = false, inheritStdio = false }: RunCommandOptions = {},
): Promise<string> {
  let builder = new CommandBuilder().command([cmd, ...args]);

  builder = inheritStdio
    ? builder.stdin("inherit").stdout("inherit").stderr("inherit")
    : builder.stdout("piped").stderr("piped");

  const result = await builder.noThrow();

  if (result.code !== 0) {
    if (allowFail) {
      return "";
    }
    const stderrText = inheritStdio ? "" : (result.stderr ?? "").trim();
    throw new Error(
      `${cmd} ${args.join(" ")} exited with ${result.code}${stderrText ? `: ${stderrText}` : ""}`,
    );
  }

  if (inheritStdio) {
    return "";
  }

  return result.stdout ?? "";
}

async function commandExists(cmd: string): Promise<boolean> {
  const result = await $`${cmd} --version`
    .stdout("null")
    .stderr("null")
    .noThrow();
  return result.code === 0;
}

const sleep = (ms: number) => new Promise<void>((resolve) => setTimeout(resolve, ms));

async function collectSessions(): Promise<SessionInfo[]> {
  const inTmux = Boolean(Deno.env.get("TMUX"));
  const currentSession = inTmux
    ? (await runCommand("tmux", [
      "display-message",
      "-p",
      "#{session_name}",
    ], { allowFail: true })).trim()
    : "";

  const sessionsRaw = await runCommand("tmux", [
    "list-sessions",
    "-F",
    "#{session_name}",
  ], { allowFail: true });

  const sessionNames = sessionsRaw
    .split(/\r?\n/)
    .map((name) => name.trim())
    .filter((name) => name.length > 0);

  const sessions: SessionInfo[] = [];

  for (const name of sessionNames) {
    const windowOutput = await runCommand("tmux", [
      "list-windows",
      "-t",
      `${name}:`,
      "-F",
      "#{window_index}\t#{window_panes}\t#{window_active}\t#{window_name}\t#{pane_current_command}",
    ], { allowFail: true });

    const windows: WindowInfo[] = [];
    let paneTotal = 0;

    const lines = windowOutput
      .split(/\r?\n/)
      .map((line) => line.trim())
      .filter((line) => line.length > 0);

    for (const line of lines) {
      const [
        index,
        panesStr,
        activeStr,
        b64Name,
        b64Command,
      ] = line.split("\t");
      if (!index) continue;
      const panes = Number.parseInt(panesStr ?? "0", 10) || 0;
      paneTotal += panes;
      const nameDecoded = b64Name ?? "";
      const commandDecoded = b64Command ?? "";
      windows.push({
        index,
        name: nameDecoded.length > 0 ? decodeTmuxString(nameDecoded) : "(unnamed)",
        panes,
        active: activeStr === "1",
        command: decodeTmuxString(commandDecoded).trim(),
      });
    }

    sessions.push({
      name,
      windows,
      totalWindows: windows.length,
      totalPanes: paneTotal,
      isCurrent: inTmux && name === currentSession,
    });
  }

  return sessions;
}

async function collectPaneInfo(target: string, recursive: boolean): Promise<PaneInfo[]> {
  const args = ["list-panes"];
  if (recursive) {
    args.push("-s");
  }
  args.push("-t", target);
  args.push("-F", "#{pane_id}\t#{pane_pid}");
  const output = await runCommand("tmux", args, { allowFail: true });
  if (!output) {
    return [];
  }

  return output
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line.length > 0)
    .map((line) => {
      const [id, pid] = line.split("\t");
      return {
        id: (id ?? "").trim(),
        pid: (pid ?? "").trim(),
      };
    })
    .filter((pane) => pane.id.length > 0);
}

type CleanKillOptions = {
  target: string;
  recursive: boolean;
  finalCommand: {
    cmd: string;
    args: string[];
  };
};

async function cleanKillTarget(options: CleanKillOptions): Promise<void> {
  const panes = await collectPaneInfo(options.target, options.recursive);
  if (panes.length === 0) {
    await runCommand(options.finalCommand.cmd, options.finalCommand.args, { allowFail: true });
    return;
  }

  const currentPane = Deno.env.get("TMUX_PANE") ?? "";
  const panesToSignal = panes.filter((pane) => pane.id !== currentPane);

  if (panesToSignal.length > 0) {
    await Promise.all(panesToSignal.map((pane) =>
      runCommand("tmux", ["send-keys", "-t", pane.id, "C-c"], { allowFail: true })
    ));
  }

  if (panesToSignal.length > 0) {
    await sleep(300);
  }

  const pgids = new Set<string>();

  for (const pane of panesToSignal) {
    const pid = pane.pid;
    if (!pid || !/^\d+$/.test(pid)) {
      continue;
    }
    const pgidOutput = (await runCommand("ps", ["-o", "pgid=", "-p", pid], { allowFail: true })).trim();
    if (!pgidOutput) {
      continue;
    }
    const normalized = pgidOutput.split(/\s+/).find((part) => part.length > 0);
    if (normalized) {
      pgids.add(normalized);
    }
  }

  if (pgids.size > 0) {
    await Promise.all(Array.from(pgids).map((pgid) =>
      runCommand("kill", ["-TERM", `-${pgid}`], { allowFail: true })
    ));
  }

  if (pgids.size > 0) {
    await sleep(300);
  }

  if (pgids.size > 0) {
    await Promise.all(Array.from(pgids).map(async (pgid) => {
      const stillRunning = (await runCommand("ps", ["-o", "pid=", "-g", pgid], { allowFail: true })).trim();
      if (stillRunning) {
        await runCommand("kill", ["-KILL", `-${pgid}`], { allowFail: true });
      }
    }));
  }

  await runCommand(options.finalCommand.cmd, options.finalCommand.args, { allowFail: true });
}

async function switchAwayFromSession(target: string): Promise<void> {
  if (!Deno.env.get("TMUX")) {
    return;
  }

  const currentSession = (await runCommand("tmux", [
    "display-message",
    "-p",
    "#{session_name}",
  ], { allowFail: true })).trim();
  if (currentSession !== target) {
    return;
  }

  const sessionsRaw = await runCommand("tmux", [
    "list-sessions",
    "-F",
    "#{session_name}",
  ], { allowFail: true });
  const names = sessionsRaw
    .split(/\r?\n/)
    .map((name) => name.trim())
    .filter((name) => name.length > 0);

  if (names.length <= 1) {
    return;
  }

  const currentIndex = names.findIndex((name) => name === target);
  const nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % names.length;
  const nextSession = names[nextIndex];

  if (!nextSession || nextSession === target) {
    return;
  }

  await runCommand("tmux", ["switch-client", "-t", nextSession], { allowFail: true });
}

async function killSessionClean(name: string): Promise<void> {
  await switchAwayFromSession(name);
  await cleanKillTarget({
    target: `${name}:`,
    recursive: true,
    finalCommand: {
      cmd: "tmux",
      args: ["kill-session", "-t", name],
    },
  });
}

async function killWindowClean(name: string): Promise<void> {
  await cleanKillTarget({
    target: name,
    recursive: false,
    finalCommand: {
      cmd: "tmux",
      args: ["kill-window", "-t", name],
    },
  });
}

async function killServerClean(): Promise<void> {
  const sessions = await collectSessions();
  const others = sessions.filter((session) => !session.isCurrent);
  for (const session of others) {
    await killSessionClean(session.name);
  }

  const current = sessions.find((session) => session.isCurrent);
  if (current) {
    await killSessionClean(current.name);
  }

  await runCommand("tmux", ["kill-server"], { allowFail: true });
}

function decodeTmuxString(value: string): string {
  // tmux can encode special characters, decode common sequences.
  if (!value) return "";
  return value
    .replace(/\\x([0-9a-fA-F]{2})/g, (_, hex) =>
      String.fromCharCode(Number.parseInt(hex, 16))
    )
    .replace(/\\([0-7]{1,3})/g, (_, oct) =>
      String.fromCharCode(Number.parseInt(oct, 8))
    )
    .replace(/\\\\/g, "\\");
}

function formatSessionDisplay(session: SessionInfo): string {
  const marker = session.isCurrent ? colors.green("*") : " ";
  return `${marker} ${colors.bold(session.name)}  ${colors.dim("|")} ${colors.dim("windows")} ${colors.cyan(String(session.totalWindows))}  ${colors.dim("|")} ${colors.dim("panes")} ${colors.cyan(String(session.totalPanes))}`;
}

function formatWindowDisplay(
  session: SessionInfo,
  window: WindowInfo,
  isLast: boolean,
): string {
  const branch = isLast ? "  └─" : "  ├─";
  const marker = window.active ? colors.green("*") : " ";
  const commandLabel = window.command ? `  ${colors.dim("|")} ${colors.dim("cmd")} ${colors.magenta(window.command)}` : "";
  return `${branch} ${marker} ${colors.bold(session.name)}:${colors.cyan(window.index)} ${window.name}  ${colors.dim("|")} ${colors.dim("panes")} ${colors.cyan(String(window.panes))}${commandLabel}`;
}

function buildEntries(sessions: SessionInfo[]): Entry[] {
  const entries: Entry[] = [];

  for (const session of sessions) {
    entries.push({
      action: "session",
      name: session.name,
      display: formatSessionDisplay(session),
    });

    session.windows.forEach((window, index) => {
      entries.push({
        action: "window",
        name: `${session.name}:${window.index}`,
        display: formatWindowDisplay(session, window, index === session.windows.length - 1),
      });
    });
  }

  const sessionCount = sessions.length;
  if (sessionCount > 1) {
    entries.push({
      action: "server",
      name: "",
      display: `  ${colors.red("✖")} ${colors.bold("tmux server")}  ${colors.dim("|")} ${colors.cyan("tmux kill-server")}`,
    });
  }

  return entries;
}

type RunFzfOptions = {
  forcePlain?: boolean;
};

async function runFzf(
  entries: Entry[],
  options: RunFzfOptions = {},
): Promise<string[]> {
  if (entries.length === 0) {
    return [];
  }

  const inTmux = Boolean(Deno.env.get("TMUX"));
  const useFzfTmux = !options.forcePlain && inTmux && await commandExists("fzf-tmux");
  const baseCmd = useFzfTmux ? "fzf-tmux" : "fzf";

  const commonArgs = [
    "--ansi",
    "--prompt=Session> ",
    "--header=Enter: switch | C-q: kill | C-t: new | C-r: rename",
    `--delimiter=${"\t"}`,
    "--with-nth=3",
    "--cycle",
    "--reverse",
    "--height=100%",
    "--no-info",
    "--no-sort",
    "--exact",
    "--expect=enter,ctrl-q,ctrl-t,ctrl-r",
    "--multi",
    "--bind=ctrl-a:select-all,ctrl-d:deselect-all",
  ];

  const args = useFzfTmux
    ? ["-p", "50%,50%", ...commonArgs]
    : commonArgs;

  const command = new Deno.Command(baseCmd, {
    args,
    stdin: "piped",
    stdout: "piped",
    stderr: "piped",
  });

  const child = command.spawn();
  const writer = child.stdin.getWriter();
  const payload = entries.map((entry) => `${entry.action}\t${entry.name}\t${entry.display}`).join("\n");
  await writer.write(encoder.encode(payload));
  await writer.write(encoder.encode("\n"));
  await writer.close();

  const { code, stdout } = await child.output();
  if (code !== 0) {
    return [];
  }

  const text = decoder.decode(stdout).trim();
  if (!text) {
    return [];
  }
  return text.split(/\r?\n/);
}

async function handleSelection(lines: string[]): Promise<void> {
  if (lines.length === 0) {
    return;
  }

  const [keyRaw, ...selections] = lines;
  const key = keyRaw?.trim() || "enter";

  if (key === "ctrl-t") {
    await runCommand("tmux", ["new-session"], { allowFail: true, inheritStdio: true });
    return;
  }

  if (key === "ctrl-q") {
    for (const line of selections) {
      const [action, name] = line.split("\t");
      if (!action) continue;
      if (action === "session" && name) {
        await killSessionClean(name);
      } else if (action === "window" && name) {
        await killWindowClean(name);
      } else if (action === "server") {
        await killServerClean();
      }
    }
    return;
  }

  if (key === "ctrl-r") {
    const [line] = selections;
    if (!line) return;
    const [action, name] = line.split("\t");
    if (!action) return;
    const sessionName = action === "session" ? name : action === "window" ? (name.split(":")[0] ?? "") : "";
    if (!sessionName) return;
    const current = sessionName;
    const next = prompt(`Rename session '${current}' to:`, current)?.trim();
    if (!next || next === current) return;
    await runCommand("tmux", ["rename-session", "-t", current, next], { allowFail: true });
    return;
  }

  // default: enter / attach / switch
  const [line] = selections;
  if (!line) return;
  const [action, name] = line.split("\t");
  if (!action) return;

  if (action === "session" && name) {
    if (Deno.env.get("TMUX")) {
      await runCommand("tmux", ["switch-client", "-t", name], { allowFail: true });
    } else {
      await runCommand("tmux", ["attach", "-t", name], { allowFail: true, inheritStdio: true });
    }
  } else if (action === "window" && name) {
    const sessionName = name.split(":")[0] ?? name;
    if (Deno.env.get("TMUX")) {
      await runCommand("tmux", ["switch-client", "-t", sessionName], { allowFail: true });
      await runCommand("tmux", ["select-window", "-t", name], { allowFail: true });
    } else {
      await runCommand("tmux", ["select-window", "-t", name], { allowFail: true });
      await runCommand("tmux", ["attach", "-t", sessionName], { allowFail: true, inheritStdio: true });
    }
  }
}

async function openPopupIfNeeded(popup: boolean): Promise<void> {
  if (!Deno.env.get("TMUX") || popup) {
    return;
  }

  const paneDir = (await runCommand("tmux", [
    "display-message",
    "-p",
    "#{pane_current_path}",
  ], { allowFail: true })).trim() || Deno.env.get("HOME") || Deno.cwd();

  const scriptPath = fromFileUrl(import.meta.url);
  const args = ["--popup"];

  try {
    const popupCmd = new Deno.Command("tmux", {
      args: [
        "display-popup",
        "-E",
        "-w",
        "50%",
        "-h",
        "50%",
        "-d",
        paneDir,
        scriptPath,
        ...args,
      ],
      stdout: "null",
      stderr: "piped",
    });
    const { code, stderr } = await popupCmd.output();
    if (code === 0) {
      Deno.exit(0);
    } else {
      const warning = decoder.decode(stderr).trim();
      if (warning.length > 0) {
        console.error(`tmux display-popup failed (${code}): ${warning}`);
      }
    }
  } catch (error) {
    console.error(`tmux display-popup not available: ${error instanceof Error ? error.message : String(error)}`);
  }
}

async function main(): Promise<void> {
  const cli = new Command()
    .name("tmux-session-manager")
    .description("tmux session manager with unified fzf shortcuts")
    .option("--popup", "Internal flag to skip popup", { default: false })
    .action(async ({ popup }: { popup: boolean }) => {
      await openPopupIfNeeded(popup);

      const sessions = await collectSessions();
      const entries = buildEntries(sessions);
      const lines = await runFzf(entries, { forcePlain: popup });
      await handleSelection(lines);
    });

  await cli.parse(Deno.args);
}

if (import.meta.main) {
  await main();
}

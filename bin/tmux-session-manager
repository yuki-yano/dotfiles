#!/usr/bin/env -S deno run --allow-run --allow-env --allow-read

import { Command } from "jsr:@cliffy/command@1.0.0-rc.7";
import { colors } from "jsr:@cliffy/ansi@1.0.0-rc.4";
import { $, CommandBuilder } from "jsr:@david/dax@0.44.0";
import { fromFileUrl } from "jsr:@std/path@1.1.3";

const decoder = new TextDecoder();
const encoder = new TextEncoder();

type Action = "session" | "window" | "create" | "server";

type WindowInfo = {
  index: string;
  name: string;
  panes: number;
  active: boolean;
  command: string;
};

type SessionInfo = {
  name: string;
  windows: WindowInfo[];
  totalWindows: number;
  totalPanes: number;
  isCurrent: boolean;
  attachedClients: number;
  lastActivity: number;
};

type Entry = {
  action: Action;
  name: string;
  display: string;
};

type RunCommandOptions = {
  allowFail?: boolean;
  inheritStdio?: boolean;
};

type PaneInfo = {
  id: string;
  pid: string;
};

type PreviewSessionInfo = {
  name: string;
  attached: number;
  windows: number;
  created: number;
  activity: number;
};

type PreviewPaneInfo = {
  index: string;
  command: string;
  width: number;
  height: number;
  active: boolean;
};

const DEFAULT_SESSION_CAPTURE_LINES = 15;
const DEFAULT_PANE_CAPTURE_LINES = 16;
const DEFAULT_FZF_BORDER = "none";
const DEFAULT_POPUP_WIDTH = "50%";
const DEFAULT_POPUP_HEIGHT = "50%";
const DEFAULT_POPUP_BORDER_LINES = "rounded";
const DEFAULT_POPUP_STYLE = "fg=#c6c6c6,bg=#1C1C1C";
const DEFAULT_POPUP_BORDER_STYLE = "fg=#8295D1,bg=#1C1C1C";
const DEFAULT_POPUP_TITLE = " Session Manager ";

const SYMBOLS = {
  sessionCurrent: "●",
  sessionAttached: "○",
  sessionDetached: "·",
  activityActive: "*",
  activityIdle: "·",
  active: "▸",
  inactive: "·",
  server: "✖",
} as const;

export function splitWindowTarget(target: string): { sessionName: string; windowIndex: string } | null {
  const sep = target.lastIndexOf(":");
  if (sep <= 0 || sep >= target.length - 1) {
    return null;
  }
  return {
    sessionName: target.slice(0, sep),
    windowIndex: target.slice(sep + 1),
  };
}

export function computeSessionCaptureLines(
  previewLines: number | null | undefined,
  windowCount: number,
  fallback = DEFAULT_SESSION_CAPTURE_LINES,
): number {
  const safeWindowCount = Math.max(0, Math.floor(windowCount));
  const safePreviewLines = previewLines && Number.isFinite(previewLines) ? Math.floor(previewLines) : 0;
  const staticLines = 11;
  const dynamicLines = 1 + safeWindowCount + 1;
  const margin = staticLines + dynamicLines;
  if (safePreviewLines > margin + 3) {
    return safePreviewLines - margin;
  }
  return fallback;
}

export function computePerPaneCaptureLines(
  previewLines: number | null | undefined,
  paneCount: number,
  fallback = DEFAULT_PANE_CAPTURE_LINES,
): number {
  const safePaneCount = Math.max(1, Math.floor(paneCount));
  const safePreviewLines = previewLines && Number.isFinite(previewLines) ? Math.floor(previewLines) : 0;
  const headerLines = 4;
  const listLines = 1 + safePaneCount + 1;
  const staticLines = headerLines + listLines;

  if (safePreviewLines > 0) {
    const available = safePreviewLines - staticLines;
    if (available > (2 * safePaneCount + 1)) {
      const computed = Math.floor(available / safePaneCount) - 2;
      return Math.max(fallback, computed, 3);
    }
  }

  return fallback;
}

function readPreviewLines(): number | null {
  const raw = Deno.env.get("FZF_PREVIEW_LINES");
  if (!raw) {
    return null;
  }
  const parsed = Number.parseInt(raw, 10);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return null;
  }
  return parsed;
}

function readPreviewColumns(): number | null {
  const raw = Deno.env.get("FZF_PREVIEW_COLUMNS");
  if (!raw) {
    return null;
  }
  const parsed = Number.parseInt(raw, 10);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return null;
  }
  return parsed;
}

function visibleLength(text: string): number {
  return Array.from(stripAnsi(text)).length;
}

export function truncateAnsiText(text: string, max: number): string {
  if (max <= 0) {
    return "";
  }

  if (visibleLength(text) <= max) {
    return text;
  }

  if (max === 1) {
    return "…";
  }

  const target = max - 1;
  const ansiPattern = /\x1b\[[0-9;]*m/g;
  let result = "";
  let visible = 0;
  let lastIndex = 0;

  for (const match of text.matchAll(ansiPattern)) {
    const index = match.index ?? 0;
    const plainChunk = text.slice(lastIndex, index);
    const plainChars = Array.from(plainChunk);

    for (const char of plainChars) {
      if (visible >= target) {
        result += "…";
        if (/\x1b\[[0-9;]*m/.test(result) && !result.endsWith("\x1b[0m")) {
          result += "\x1b[0m";
        }
        return result;
      }
      result += char;
      visible += 1;
    }

    result += match[0];
    lastIndex = index + match[0].length;
  }

  const rest = text.slice(lastIndex);
  for (const char of Array.from(rest)) {
    if (visible >= target) {
      result += "…";
      if (/\x1b\[[0-9;]*m/.test(result) && !result.endsWith("\x1b[0m")) {
        result += "\x1b[0m";
      }
      return result;
    }
    result += char;
    visible += 1;
  }

  result += "…";
  if (/\x1b\[[0-9;]*m/.test(result) && !result.endsWith("\x1b[0m")) {
    result += "\x1b[0m";
  }
  return result;
}

function padAnsiRight(text: string, width: number): string {
  const len = visibleLength(text);
  if (len >= width) {
    return text;
  }
  return text + " ".repeat(width - len);
}

function fitPreviewLine(line: string, padding = 3): string {
  const columns = readPreviewColumns();
  if (!columns) {
    return line;
  }
  const maxWidth = Math.max(20, columns - padding);
  return truncateAnsiText(line, maxWidth);
}

function parseIntSafe(raw: string | undefined, fallback = 0): number {
  const parsed = Number.parseInt(raw ?? "", 10);
  if (Number.isFinite(parsed)) {
    return parsed;
  }
  return fallback;
}

function formatAgoFromEpoch(epochSeconds: number): string {
  if (!Number.isFinite(epochSeconds) || epochSeconds <= 0) {
    return "unknown";
  }

  const nowSeconds = Math.floor(Date.now() / 1000);
  const delta = Math.max(0, nowSeconds - epochSeconds);

  if (delta < 60) {
    return `${delta}s ago`;
  }
  if (delta < 3600) {
    return `${Math.floor(delta / 60)}m ago`;
  }
  if (delta < 86_400) {
    return `${Math.floor(delta / 3600)}h ago`;
  }
  return `${Math.floor(delta / 86_400)}d ago`;
}

function getPaneIcon(command: string): string {
  switch (command) {
    case "vim":
    case "nvim":
      return "V";
    case "bash":
    case "zsh":
    case "fish":
      return "S";
    case "ssh":
      return "K";
    default:
      return "C";
  }
}

function stripAnsi(text: string): string {
  return text.replace(/\x1b\[[0-9;]*m/g, "");
}

function truncateText(text: string, max: number): string {
  const chars = Array.from(text);
  if (chars.length <= max) {
    return text;
  }
  if (max <= 1) {
    return "…";
  }
  return `${chars.slice(0, max - 1).join("")}…`;
}

function padVisible(text: string, width: number): string {
  const current = Array.from(stripAnsi(text)).length;
  if (current >= width) {
    return truncateText(text, width);
  }
  return text + " ".repeat(width - current);
}

function renderHeaderBox(title: string, width = 60): string[] {
  const safeTitle = padVisible(` ${truncateText(title, width - 2)} `, width);
  return [
    colors.magenta(`┌${"─".repeat(width)}┐`),
    `${colors.magenta("│")}${colors.bold(colors.cyan(safeTitle))}${colors.magenta("│")}`,
    colors.magenta(`└${"─".repeat(width)}┘`),
  ];
}

function renderInfoBlock(rows: Array<{ label: string; value: string }>, title = "Info"): string[] {
  const lines = [colors.bold(colors.blue(`┌─ ${title}`))];
  if (rows.length === 0) {
    lines.push(`${colors.blue("└─")} ${colors.dim("(none)")}`);
    return lines;
  }

  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    const branch = i === rows.length - 1 ? "└─" : "├─";
    lines.push(`${colors.blue(branch)} ${colors.dim(row.label.padEnd(14))} ${row.value}`);
  }

  return lines;
}

function renderPanePreviewBlock(
  title: string,
  paneLines: string[],
  emptyLabel: string,
): string[] {
  const columns = readPreviewColumns();
  const innerWidth = columns ? Math.max(24, columns - 2) : 76;
  const normalizedTitle = padVisible(` ${truncateText(stripAnsi(title), innerWidth - 2)} `, innerWidth);
  const body = paneLines.length > 0 ? paneLines : [emptyLabel];

  const lines: string[] = [];
  lines.push(colors.blue(`┌${"─".repeat(innerWidth)}┐`));
  lines.push(`${colors.blue("│")}${colors.bold(colors.cyan(normalizedTitle))}${colors.blue("│")}`);
  lines.push(colors.blue(`├${"─".repeat(innerWidth)}┤`));
  for (const line of body) {
    const content = padAnsiRight(truncateAnsiText(line, innerWidth), innerWidth);
    lines.push(`${colors.blue("│")}${content}${colors.blue("│")}`);
  }
  lines.push(colors.blue(`└${"─".repeat(innerWidth)}┘`));
  return lines;
}

function getSessionStateSymbol(session: SessionInfo): string {
  if (session.isCurrent) {
    return colors.green(SYMBOLS.sessionCurrent);
  }
  if (session.attachedClients > 0) {
    return colors.yellow(SYMBOLS.sessionAttached);
  }
  return colors.dim(SYMBOLS.sessionDetached);
}

function getActivityBadge(lastActivity: number): string {
  if (!Number.isFinite(lastActivity) || lastActivity <= 0) {
    return colors.dim(SYMBOLS.activityIdle);
  }
  const nowSeconds = Math.floor(Date.now() / 1000);
  const delta = Math.max(0, nowSeconds - lastActivity);
  if (delta <= 3600) {
    return colors.yellow(SYMBOLS.activityActive);
  }
  return colors.dim(SYMBOLS.activityIdle);
}

function buildFzfBorderOption(style: string): string {
  const normalized = style.trim().toLowerCase();
  if (["", "none", "0", "false", "off"].includes(normalized)) {
    return "--border=none";
  }
  return `--border=${style.trim()}`;
}

function nonEmptyOption(value: string): string | null {
  const normalized = value.trim();
  return normalized.length > 0 ? normalized : null;
}

function buildPopupBorderArgs(style: string): string[] {
  const normalized = style.trim().toLowerCase();
  if (["", "default", "inherit"].includes(normalized)) {
    return [];
  }
  if (["none", "off", "0", "false", "no"].includes(normalized)) {
    return ["-B"];
  }
  return ["-b", style.trim()];
}

async function getTmuxOption(name: string, fallback: string): Promise<string> {
  const value = (await runCommand("tmux", ["show-option", "-gqv", `@${name}`], { allowFail: true })).trim();
  return value.length > 0 ? value : fallback;
}

async function runCommand(
  cmd: string,
  args: string[],
  { allowFail = false, inheritStdio = false }: RunCommandOptions = {},
): Promise<string> {
  let builder = new CommandBuilder().command([cmd, ...args]);

  builder = inheritStdio
    ? builder.stdin("inherit").stdout("inherit").stderr("inherit")
    : builder.stdout("piped").stderr("piped");

  const result = await builder.noThrow();

  if (result.code !== 0) {
    if (allowFail) {
      return "";
    }
    const stderrText = inheritStdio ? "" : (result.stderr ?? "").trim();
    throw new Error(
      `${cmd} ${args.join(" ")} exited with ${result.code}${stderrText ? `: ${stderrText}` : ""}`,
    );
  }

  if (inheritStdio) {
    return "";
  }

  return result.stdout ?? "";
}

async function commandExists(cmd: string): Promise<boolean> {
  const result = await $`${cmd} --version`
    .stdout("null")
    .stderr("null")
    .noThrow();
  return result.code === 0;
}

const sleep = (ms: number) => new Promise<void>((resolve) => setTimeout(resolve, ms));

async function collectWindowsForSession(name: string): Promise<WindowInfo[]> {
  const windowOutput = await runCommand("tmux", [
    "list-windows",
    "-t",
    `${name}:`,
    "-F",
    "#{window_index}\t#{window_panes}\t#{window_active}\t#{window_name}\t#{pane_current_command}",
  ], { allowFail: true });

  const lines = windowOutput
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line.length > 0);

  const windows: WindowInfo[] = [];
  for (const line of lines) {
    const [index, panesStr, activeStr, rawName, rawCommand] = line.split("\t");
    if (!index) {
      continue;
    }

    windows.push({
      index,
      name: rawName ? decodeTmuxString(rawName) : "(unnamed)",
      panes: parseIntSafe(panesStr, 0),
      active: activeStr === "1",
      command: decodeTmuxString(rawCommand ?? "").trim(),
    });
  }

  return windows;
}

async function collectSessions(): Promise<SessionInfo[]> {
  const inTmux = Boolean(Deno.env.get("TMUX"));
  const currentSession = inTmux
    ? (await runCommand("tmux", [
      "display-message",
      "-p",
      "#{session_name}",
    ], { allowFail: true })).trim()
    : "";

  const sessionsRaw = await runCommand("tmux", [
    "list-sessions",
    "-F",
    "#{session_name}\t#{session_attached}\t#{session_activity}",
  ], { allowFail: true });

  const sessionMetas = sessionsRaw
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line.length > 0)
    .map((line) => {
      const [name, attached, activity] = line.split("\t");
      return {
        name: (name ?? "").trim(),
        attachedClients: parseIntSafe(attached, 0),
        lastActivity: parseIntSafe(activity, 0),
      };
    })
    .filter((meta) => meta.name.length > 0);

  const sessions: SessionInfo[] = [];
  for (const meta of sessionMetas) {
    const windows = await collectWindowsForSession(meta.name);
    const paneTotal = windows.reduce((sum, window) => sum + window.panes, 0);
    sessions.push({
      name: meta.name,
      windows,
      totalWindows: windows.length,
      totalPanes: paneTotal,
      isCurrent: inTmux && meta.name === currentSession,
      attachedClients: meta.attachedClients,
      lastActivity: meta.lastActivity,
    });
  }

  return sessions;
}

async function collectPreviewSessionInfo(sessionName: string): Promise<PreviewSessionInfo | null> {
  const raw = await runCommand("tmux", [
    "list-sessions",
    "-F",
    "#{session_name}\t#{session_attached}\t#{session_windows}\t#{session_created}\t#{session_activity}",
  ], { allowFail: true });

  const lines = raw
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line.length > 0);

  for (const line of lines) {
    const [name, attached, windows, created, activity] = line.split("\t");
    if (name !== sessionName) {
      continue;
    }

    return {
      name,
      attached: parseIntSafe(attached, 0),
      windows: parseIntSafe(windows, 0),
      created: parseIntSafe(created, 0),
      activity: parseIntSafe(activity, 0),
    };
  }

  return null;
}

async function collectPreviewPanes(sessionName: string, windowIndex: string): Promise<PreviewPaneInfo[]> {
  const raw = await runCommand("tmux", [
    "list-panes",
    "-t",
    `${sessionName}:${windowIndex}`,
    "-F",
    "#{pane_index}\t#{pane_current_command}\t#{pane_width}\t#{pane_height}\t#{pane_active}",
  ], { allowFail: true });

  return raw
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line.length > 0)
    .map((line) => {
      const [index, command, width, height, active] = line.split("\t");
      return {
        index: index ?? "",
        command: (command ?? "").trim(),
        width: parseIntSafe(width, 0),
        height: parseIntSafe(height, 0),
        active: active === "1",
      };
    })
    .filter((pane) => pane.index.length > 0);
}

async function capturePaneTail(target: string, tailLines: number): Promise<string[]> {
  if (tailLines <= 0) {
    return [];
  }

  const raw = await runCommand("tmux", [
    "capture-pane",
    "-t",
    target,
    "-J",
    "-N",
    "-e",
    "-p",
  ], { allowFail: true });

  if (!raw) {
    return [];
  }

  const lines = raw.replace(/\r/g, "").split("\n");
  while (lines.length > 0 && lines[lines.length - 1] === "") {
    lines.pop();
  }
  return lines.slice(-tailLines);
}

async function collectPaneInfo(target: string, recursive: boolean): Promise<PaneInfo[]> {
  const args = ["list-panes"];
  if (recursive) {
    args.push("-s");
  }
  args.push("-t", target);
  args.push("-F", "#{pane_id}\t#{pane_pid}");
  const output = await runCommand("tmux", args, { allowFail: true });
  if (!output) {
    return [];
  }

  return output
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line.length > 0)
    .map((line) => {
      const [id, pid] = line.split("\t");
      return {
        id: (id ?? "").trim(),
        pid: (pid ?? "").trim(),
      };
    })
    .filter((pane) => pane.id.length > 0);
}

type CleanKillOptions = {
  target: string;
  recursive: boolean;
  finalCommand: {
    cmd: string;
    args: string[];
  };
};

async function cleanKillTarget(options: CleanKillOptions): Promise<void> {
  const panes = await collectPaneInfo(options.target, options.recursive);
  if (panes.length === 0) {
    await runCommand(options.finalCommand.cmd, options.finalCommand.args, { allowFail: true });
    return;
  }

  const currentPane = Deno.env.get("TMUX_PANE") ?? "";
  const panesToSignal = panes.filter((pane) => pane.id !== currentPane);

  if (panesToSignal.length > 0) {
    await Promise.all(
      panesToSignal.map((pane) => runCommand("tmux", ["send-keys", "-t", pane.id, "C-c"], { allowFail: true })),
    );
  }

  if (panesToSignal.length > 0) {
    await sleep(300);
  }

  const pgids = new Set<string>();

  for (const pane of panesToSignal) {
    const pid = pane.pid;
    if (!pid || !/^\d+$/.test(pid)) {
      continue;
    }
    const pgidOutput = (await runCommand("ps", ["-o", "pgid=", "-p", pid], { allowFail: true })).trim();
    if (!pgidOutput) {
      continue;
    }
    const normalized = pgidOutput.split(/\s+/).find((part) => part.length > 0);
    if (normalized) {
      pgids.add(normalized);
    }
  }

  if (pgids.size > 0) {
    await Promise.all(Array.from(pgids).map((pgid) => runCommand("kill", ["-TERM", `-${pgid}`], { allowFail: true })));
  }

  if (pgids.size > 0) {
    await sleep(300);
  }

  if (pgids.size > 0) {
    await Promise.all(
      Array.from(pgids).map(async (pgid) => {
        const stillRunning = (await runCommand("ps", ["-o", "pid=", "-g", pgid], { allowFail: true })).trim();
        if (stillRunning) {
          await runCommand("kill", ["-KILL", `-${pgid}`], { allowFail: true });
        }
      }),
    );
  }

  await runCommand(options.finalCommand.cmd, options.finalCommand.args, { allowFail: true });
}

async function switchAwayFromSession(target: string): Promise<void> {
  if (!Deno.env.get("TMUX")) {
    return;
  }

  const currentSession = (await runCommand("tmux", [
    "display-message",
    "-p",
    "#{session_name}",
  ], { allowFail: true })).trim();
  if (currentSession !== target) {
    return;
  }

  const sessionsRaw = await runCommand("tmux", [
    "list-sessions",
    "-F",
    "#{session_name}",
  ], { allowFail: true });
  const names = sessionsRaw
    .split(/\r?\n/)
    .map((name) => name.trim())
    .filter((name) => name.length > 0);

  if (names.length <= 1) {
    return;
  }

  const currentIndex = names.findIndex((name) => name === target);
  const nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % names.length;
  const nextSession = names[nextIndex];

  if (!nextSession || nextSession === target) {
    return;
  }

  await runCommand("tmux", ["switch-client", "-t", nextSession], { allowFail: true });
}

async function killSessionClean(name: string): Promise<void> {
  await switchAwayFromSession(name);
  await cleanKillTarget({
    target: `${name}:`,
    recursive: true,
    finalCommand: {
      cmd: "tmux",
      args: ["kill-session", "-t", name],
    },
  });
}

async function killWindowClean(name: string): Promise<void> {
  await cleanKillTarget({
    target: name,
    recursive: false,
    finalCommand: {
      cmd: "tmux",
      args: ["kill-window", "-t", name],
    },
  });
}

async function killServerClean(): Promise<void> {
  const sessions = await collectSessions();
  const others = sessions.filter((session) => !session.isCurrent);
  for (const session of others) {
    await killSessionClean(session.name);
  }

  const current = sessions.find((session) => session.isCurrent);
  if (current) {
    await killSessionClean(current.name);
  }

  await runCommand("tmux", ["kill-server"], { allowFail: true });
}

function decodeTmuxString(value: string): string {
  // tmux can encode special characters, decode common sequences.
  if (!value) return "";
  return value
    .replace(/\\x([0-9a-fA-F]{2})/g, (_, hex) => String.fromCharCode(Number.parseInt(hex, 16)))
    .replace(/\\([0-7]{1,3})/g, (_, oct) => String.fromCharCode(Number.parseInt(oct, 8)))
    .replace(/\\\\/g, "\\");
}

function formatSessionDisplay(session: SessionInfo): string {
  const state = getSessionStateSymbol(session);
  const activity = getActivityBadge(session.lastActivity);
  const attached = session.attachedClients > 0
    ? colors.yellow(`attached:${session.attachedClients}`)
    : colors.dim("detached");
  return `${state} ${activity} ${colors.bold(session.name)}  ${colors.dim("|")} ${colors.dim("win")} ${
    colors.cyan(String(session.totalWindows))
  }  ${colors.dim("|")} ${colors.dim("pane")} ${colors.cyan(String(session.totalPanes))}  ${
    colors.dim("|")
  } ${attached}`;
}

function formatWindowDisplay(
  session: SessionInfo,
  window: WindowInfo,
  isLast: boolean,
): string {
  const branch = isLast ? "  └─" : "  ├─";
  const marker = window.active ? colors.green(SYMBOLS.active) : colors.dim(SYMBOLS.inactive);
  const commandLabel = window.command
    ? `  ${colors.dim("|")} ${colors.dim("cmd")} ${colors.magenta(truncateText(window.command, 28))}`
    : "";
  return `${branch} ${marker} ${colors.bold(session.name)}:${colors.cyan(window.index)} ${
    truncateText(window.name, 24)
  }  ${colors.dim("|")} ${colors.dim("pane")} ${colors.cyan(String(window.panes))}${commandLabel}`;
}

function buildEntries(sessions: SessionInfo[]): Entry[] {
  const entries: Entry[] = [];

  for (const session of sessions) {
    entries.push({
      action: "session",
      name: session.name,
      display: formatSessionDisplay(session),
    });

    session.windows.forEach((window, index) => {
      entries.push({
        action: "window",
        name: `${session.name}:${window.index}`,
        display: formatWindowDisplay(session, window, index === session.windows.length - 1),
      });
    });
  }

  const sessionCount = sessions.length;
  if (sessionCount > 1) {
    entries.push({
      action: "server",
      name: "",
      display: `  ${colors.red(SYMBOLS.server)} ${colors.bold("tmux server")}  ${colors.dim("|")} ${
        colors.cyan("tmux kill-server")
      }`,
    });
  }

  return entries;
}

async function renderSessionPreview(sessionName: string): Promise<string> {
  const info = await collectPreviewSessionInfo(sessionName);
  if (!info) {
    return colors.red(`Session not found: ${sessionName}`);
  }

  const windows = await collectWindowsForSession(sessionName);
  const activeWindow = windows.find((window) => window.active) ?? windows[0];
  const captureLines = computeSessionCaptureLines(readPreviewLines(), windows.length);
  const panePreview = activeWindow ? await capturePaneTail(`${sessionName}:${activeWindow.index}.0`, captureLines) : [];

  const lines: string[] = [];
  lines.push(...renderHeaderBox(`Session ${sessionName}`));
  lines.push("");
  lines.push(
    ...renderInfoBlock([
      {
        label: "Status",
        value: info.attached > 0 ? colors.yellow(`attached (${info.attached})`) : colors.dim("detached"),
      },
      { label: "Windows", value: colors.cyan(String(info.windows)) },
      { label: "Created", value: colors.dim(formatAgoFromEpoch(info.created)) },
      {
        label: "Last Activity",
        value: `${getActivityBadge(info.activity)} ${colors.dim(formatAgoFromEpoch(info.activity))}`,
      },
    ], "Session Info"),
  );
  lines.push("");
  lines.push(colors.bold(colors.blue("┌─ Windows")));
  if (windows.length === 0) {
    lines.push(`${colors.blue("└─")} ${colors.dim("(no windows)")}`);
  } else {
    for (let i = 0; i < windows.length; i++) {
      const window = windows[i];
      const marker = window.active ? colors.green(SYMBOLS.active) : colors.dim(SYMBOLS.inactive);
      const branch = i === windows.length - 1 ? "└─" : "├─";
      const commandLabel = window.command.length > 0 ? ` ${colors.dim(`cmd:${truncateText(window.command, 28)}`)}` : "";
      lines.push(
        `${colors.blue(branch)} ${marker} ${colors.cyan(window.index)} ${truncateText(window.name, 26)} ${
          colors.dim(`[${window.panes}P]`)
        }${commandLabel}`,
      );
    }
  }
  lines.push("");
  const activePreviewTitle = activeWindow
    ? `Active Pane ${sessionName}:${activeWindow.index}.0 (last ${captureLines} lines)`
    : `Active Pane (last ${captureLines} lines)`;
  lines.push(
    ...renderPanePreviewBlock(
      activePreviewTitle,
      panePreview.map((line) => fitPreviewLine(line)),
      activeWindow ? "(preview not available)" : "(active window not found)",
    ),
  );

  return lines.join("\n");
}

async function renderWindowPreview(target: string): Promise<string> {
  const resolved = splitWindowTarget(target);
  if (!resolved) {
    return colors.red(`Invalid window target: ${target}`);
  }

  const { sessionName, windowIndex } = resolved;
  const windows = await collectWindowsForSession(sessionName);
  const targetWindow = windows.find((window) => window.index === windowIndex);
  if (!targetWindow) {
    return colors.red(`Window not found: ${sessionName}:${windowIndex}`);
  }

  const panes = await collectPreviewPanes(sessionName, windowIndex);
  const perPaneLines = computePerPaneCaptureLines(readPreviewLines(), panes.length);

  const lines: string[] = [];
  lines.push(...renderHeaderBox(`Window ${sessionName}:${windowIndex}`));
  lines.push("");
  lines.push(
    ...renderInfoBlock([
      { label: "Name", value: truncateText(targetWindow.name, 40) },
      { label: "Panes", value: colors.cyan(String(targetWindow.panes)) },
      {
        label: "Command",
        value: targetWindow.command ? colors.magenta(targetWindow.command) : colors.dim("(unknown)"),
      },
    ], "Window Info"),
  );
  lines.push("");
  lines.push(colors.bold(colors.blue("┌─ Pane List")));

  if (panes.length === 0) {
    lines.push(`${colors.blue("└─")} ${colors.dim("(no panes)")}`);
    return lines.join("\n");
  }

  for (let i = 0; i < panes.length; i++) {
    const pane = panes[i];
    const marker = pane.active ? colors.green(SYMBOLS.active) : colors.dim(SYMBOLS.inactive);
    const branch = i === panes.length - 1 ? "└─" : "├─";
    lines.push(
      `${colors.blue(branch)} ${marker} ${pane.index}: ${getPaneIcon(pane.command)} ${
        truncateText(pane.command || "(unknown)", 20)
      } ${colors.dim(`(${pane.width}x${pane.height})`)}`,
    );
  }

  lines.push("");
  lines.push(colors.bold(colors.blue(`┌─ Pane Preview (last ${perPaneLines} lines each)`)));

  for (let i = 0; i < panes.length; i++) {
    const pane = panes[i];
    const paneLines = await capturePaneTail(`${sessionName}:${windowIndex}.${pane.index}`, perPaneLines);
    const titlePrefix = pane.active ? SYMBOLS.active : SYMBOLS.inactive;
    const title = `${titlePrefix} Pane ${pane.index} (${truncateText(pane.command || "unknown", 24)})`;
    lines.push(
      ...renderPanePreviewBlock(
        title,
        paneLines.map((paneLine) => fitPreviewLine(paneLine)),
        "(preview not available)",
      ),
    );
    if (i < panes.length - 1) {
      lines.push("");
    }
  }

  return lines.join("\n");
}

function renderServerPreview(): string {
  return [
    ...renderHeaderBox("tmux server", 46),
    "",
    "Selecting this row with Ctrl-q will run:",
    colors.cyan("tmux kill-server"),
    "",
    colors.dim("All sessions will be terminated."),
    colors.dim("Use with caution."),
  ].join("\n");
}

async function renderPreviewOnce(action: string, name: string): Promise<string> {
  if (action === "session") {
    return await renderSessionPreview(name);
  }
  if (action === "window") {
    return await renderWindowPreview(name);
  }
  if (action === "server") {
    return renderServerPreview();
  }
  return colors.dim("Preview not available");
}

type RunFzfOptions = {
  forcePlain?: boolean;
};

async function runFzf(
  entries: Entry[],
  options: RunFzfOptions = {},
): Promise<string[]> {
  if (entries.length === 0) {
    return [];
  }

  const inTmux = Boolean(Deno.env.get("TMUX"));
  const useFzfTmux = !options.forcePlain && inTmux && await commandExists("fzf-tmux");
  const baseCmd = useFzfTmux ? "fzf-tmux" : "fzf";
  const fzfBorderStyle = await getTmuxOption("session-manager-fzf-border", DEFAULT_FZF_BORDER);
  const fzfBorderOption = buildFzfBorderOption(fzfBorderStyle);

  const commonArgs = [
    "--ansi",
    "--prompt=tmux> ",
    "--header=Enter switch | C-q kill | C-t new | C-r rename",
    fzfBorderOption,
    `--delimiter=${"\t"}`,
    "--with-nth=3",
    "--cycle",
    "--reverse",
    "--height=100%",
    "--no-info",
    "--no-sort",
    "--exact",
    "--expect=enter,ctrl-q,ctrl-t,ctrl-r",
    "--multi",
  ];

  const args = useFzfTmux ? ["-p", "50%,50%", ...commonArgs] : commonArgs;

  const command = new Deno.Command(baseCmd, {
    args,
    stdin: "piped",
    stdout: "piped",
    stderr: "piped",
  });

  const child = command.spawn();
  const writer = child.stdin.getWriter();
  const payload = entries.map((entry) => `${entry.action}\t${entry.name}\t${entry.display}`).join("\n");
  await writer.write(encoder.encode(payload));
  await writer.write(encoder.encode("\n"));
  await writer.close();

  const { code, stdout } = await child.output();
  if (code !== 0) {
    return [];
  }

  const text = decoder.decode(stdout).trim();
  if (!text) {
    return [];
  }
  return text.split(/\r?\n/);
}

async function handleSelection(lines: string[]): Promise<void> {
  if (lines.length === 0) {
    return;
  }

  const [keyRaw, ...selections] = lines;
  const key = keyRaw?.trim() || "enter";

  if (key === "ctrl-t") {
    const inTmux = Boolean(Deno.env.get("TMUX"));
    const inPopup = Boolean(Deno.env.get("TMUX_POPUP"));

    if (inTmux) {
      const created = (await runCommand("tmux", [
        "new-session",
        "-d",
        "-P",
        "-F",
        "#{session_name}",
      ], { allowFail: true })).trim();

      const target = created || "";
      if (target) {
        await runCommand("tmux", ["switch-client", "-t", target], { allowFail: true });
      } else {
        await runCommand("tmux", ["new-session"], { allowFail: true, inheritStdio: true });
      }

      if (inPopup) {
        Deno.exit(0);
      }
      return;
    }

    await runCommand("tmux", ["new-session"], { allowFail: true, inheritStdio: true });
    return;
  }

  if (key === "ctrl-q") {
    const targets = new Set<string>();
    for (const line of selections) {
      const [action, name] = line.split("\t");
      if (!action) continue;
      if (action === "session" && name) {
        targets.add(name);
      } else if (action === "window" && name) {
        const sessionName = splitWindowTarget(name)?.sessionName ?? "";
        if (sessionName) {
          targets.add(sessionName);
        }
      }
    }

    const inTmux = Boolean(Deno.env.get("TMUX"));
    if (inTmux && targets.size > 0) {
      const sessions = await collectSessions();
      const current = sessions.find((session) => session.isCurrent);
      const fallback = sessions.find((session) => !targets.has(session.name));
      if (current && targets.has(current.name) && fallback) {
        await runCommand("tmux", ["switch-client", "-t", fallback.name], { allowFail: true });
      }
    }

    for (const line of selections) {
      const [action, name] = line.split("\t");
      if (!action) continue;
      if (action === "session" && name) {
        await killSessionClean(name);
      } else if (action === "window" && name) {
        await killWindowClean(name);
      } else if (action === "server") {
        await killServerClean();
      }
    }
    return;
  }

  if (key === "ctrl-r") {
    const [line] = selections;
    if (!line) return;
    const [action, name] = line.split("\t");
    if (!action) return;
    const sessionName = action === "session"
      ? name
      : action === "window"
      ? (splitWindowTarget(name)?.sessionName ?? "")
      : "";
    if (!sessionName) return;
    const current = sessionName;
    const next = prompt(`Rename session '${current}' to:`, current)?.trim();
    if (!next || next === current) return;
    await runCommand("tmux", ["rename-session", "-t", current, next], { allowFail: true });
    return;
  }

  // default: enter / attach / switch
  const [line] = selections;
  if (!line) return;
  const [action, name] = line.split("\t");
  if (!action) return;

  if (action === "session" && name) {
    if (Deno.env.get("TMUX")) {
      await runCommand("tmux", ["switch-client", "-t", name], { allowFail: true });
    } else {
      await runCommand("tmux", ["attach", "-t", name], { allowFail: true, inheritStdio: true });
    }
  } else if (action === "window" && name) {
    const sessionName = splitWindowTarget(name)?.sessionName ?? name;
    if (Deno.env.get("TMUX")) {
      await runCommand("tmux", ["switch-client", "-t", sessionName], { allowFail: true });
      await runCommand("tmux", ["select-window", "-t", name], { allowFail: true });
    } else {
      await runCommand("tmux", ["select-window", "-t", name], { allowFail: true });
      await runCommand("tmux", ["attach", "-t", sessionName], { allowFail: true, inheritStdio: true });
    }
  }
}

async function openPopupIfNeeded(popup: boolean): Promise<void> {
  if (!Deno.env.get("TMUX") || popup) {
    return;
  }

  const paneDir = (await runCommand("tmux", [
    "display-message",
    "-p",
    "#{pane_current_path}",
  ], { allowFail: true })).trim() || Deno.env.get("HOME") || Deno.cwd();

  const scriptPath = fromFileUrl(import.meta.url);
  const scriptArgs = ["--popup"];
  const [
    popupWidth,
    popupHeight,
    popupBorderLines,
    popupStyle,
    popupBorderStyle,
    popupTitle,
  ] = await Promise.all([
    getTmuxOption("session-manager-popup-width", DEFAULT_POPUP_WIDTH),
    getTmuxOption("session-manager-popup-height", DEFAULT_POPUP_HEIGHT),
    getTmuxOption("session-manager-popup-border-lines", DEFAULT_POPUP_BORDER_LINES),
    getTmuxOption("session-manager-popup-style", DEFAULT_POPUP_STYLE),
    getTmuxOption("session-manager-popup-border-style", DEFAULT_POPUP_BORDER_STYLE),
    getTmuxOption("session-manager-popup-title", DEFAULT_POPUP_TITLE),
  ]);

  const popupArgs = [
    "display-popup",
    "-E",
    "-w",
    popupWidth,
    "-h",
    popupHeight,
    ...buildPopupBorderArgs(popupBorderLines),
    "-d",
    paneDir,
  ];
  const normalizedPopupStyle = nonEmptyOption(popupStyle);
  if (normalizedPopupStyle) {
    popupArgs.push("-s", normalizedPopupStyle);
  }
  const normalizedPopupBorderStyle = nonEmptyOption(popupBorderStyle);
  if (normalizedPopupBorderStyle) {
    popupArgs.push("-S", normalizedPopupBorderStyle);
  }
  const normalizedPopupTitle = nonEmptyOption(popupTitle);
  if (normalizedPopupTitle) {
    popupArgs.push("-T", normalizedPopupTitle);
  }
  popupArgs.push(scriptPath, ...scriptArgs);

  try {
    const popupCmd = new Deno.Command("tmux", {
      args: popupArgs,
      stdout: "null",
      stderr: "piped",
    });
    const { code, stderr } = await popupCmd.output();
    if (code === 0) {
      Deno.exit(0);
    } else {
      const warning = decoder.decode(stderr).trim();
      if (warning.length > 0) {
        console.error(`tmux display-popup failed (${code}): ${warning}`);
      }
    }
  } catch (error) {
    console.error(`tmux display-popup not available: ${error instanceof Error ? error.message : String(error)}`);
  }
}

async function main(): Promise<void> {
  const cli = new Command()
    .name("tmux-session-manager")
    .description("tmux session manager with unified fzf shortcuts")
    .option("--popup", "Internal flag to skip popup", { default: false })
    .action(async (
      { popup }: { popup: boolean },
    ) => {
      await openPopupIfNeeded(popup);

      const sessions = await collectSessions();
      const inTmux = Boolean(Deno.env.get("TMUX"));

      if (!inTmux && sessions.length === 0) {
        await runCommand("tmux", ["new-session"], { inheritStdio: true });
        return;
      }

      const entries = buildEntries(sessions);
      const lines = await runFzf(entries, { forcePlain: popup });
      await handleSelection(lines);
    });

  await cli.parse(Deno.args);
}

if (import.meta.main) {
  await main();
}

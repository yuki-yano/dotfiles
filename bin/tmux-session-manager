#!/usr/bin/env -S deno run --allow-run --allow-env --allow-read

import { Command } from "jsr:@cliffy/command@1.0.0-rc.7";
import { colors } from "https://deno.land/x/cliffy@v1.0.0-rc.4/ansi/colors.ts";
import { fromFileUrl } from "https://deno.land/std@0.224.0/path/mod.ts";

const decoder = new TextDecoder();
const encoder = new TextEncoder();

type Mode = "select" | "kill";
type Action = "session" | "window" | "create" | "server";

interface WindowInfo {
  index: string;
  name: string;
  panes: number;
  active: boolean;
  command: string;
}

interface SessionInfo {
  name: string;
  windows: WindowInfo[];
  totalWindows: number;
  totalPanes: number;
  isCurrent: boolean;
}

interface Entry {
  action: Action;
  name: string;
  display: string;
}

interface RunCommandOptions {
  allowFail?: boolean;
  inheritStdio?: boolean;
}

interface PaneInfo {
  id: string;
  pid: string;
}

async function runCommand(
  cmd: string,
  args: string[],
  { allowFail = false, inheritStdio = false }: RunCommandOptions = {},
): Promise<string> {
  const commandOptions: Deno.CommandOptions = {
    args,
    stdout: inheritStdio ? "inherit" : "piped",
    stderr: inheritStdio ? "inherit" : "piped",
  };

  if (inheritStdio) {
    commandOptions.stdin = "inherit";
  }

  const command = new Deno.Command(cmd, commandOptions);

  try {
    if (inheritStdio) {
      const child = command.spawn();
      const { code } = await child.status;
      if (code !== 0) {
        if (allowFail) {
          return "";
        }
        throw new Error(`${cmd} ${args.join(" ")} exited with ${code}`);
      }
      return "";
    }

    const { code, stdout, stderr } = await command.output();
    if (code !== 0) {
      if (allowFail) {
        return "";
      }
      const errorText = decoder.decode(stderr).trim();
      throw new Error(
        `${cmd} ${args.join(" ")} exited with ${code}${errorText ? `: ${errorText}` : ""}`,
      );
    }
    return decoder.decode(stdout);
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      throw new Error(`${cmd} not found in PATH`);
    }
    if (allowFail) {
      return "";
    }
    throw error;
  }
}

async function commandExists(cmd: string): Promise<boolean> {
  try {
    const command = new Deno.Command(cmd, {
      args: ["--version"],
      stdout: "null",
      stderr: "null",
    });
    await command.output();
    return true;
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      return false;
    }
    return true;
  }
}

const sleep = (ms: number) => new Promise<void>((resolve) => setTimeout(resolve, ms));

async function collectSessions(): Promise<SessionInfo[]> {
  const inTmux = Boolean(Deno.env.get("TMUX"));
  const currentSession = inTmux
    ? (await runCommand("tmux", [
      "display-message",
      "-p",
      "#{session_name}",
    ], { allowFail: true })).trim()
    : "";

  const sessionsRaw = await runCommand("tmux", [
    "list-sessions",
    "-F",
    "#{session_name}",
  ], { allowFail: true });

  const sessionNames = sessionsRaw
    .split(/\r?\n/)
    .map((name) => name.trim())
    .filter((name) => name.length > 0);

  const sessions: SessionInfo[] = [];

  for (const name of sessionNames) {
    const windowOutput = await runCommand("tmux", [
      "list-windows",
      "-t",
      `${name}:`,
      "-F",
      "#{window_index}\t#{window_panes}\t#{window_active}\t#{window_name}\t#{pane_current_command}",
    ], { allowFail: true });

    const windows: WindowInfo[] = [];
    let paneTotal = 0;

    const lines = windowOutput
      .split(/\r?\n/)
      .map((line) => line.trim())
      .filter((line) => line.length > 0);

    for (const line of lines) {
      const [
        index,
        panesStr,
        activeStr,
        b64Name,
        b64Command,
      ] = line.split("\t");
      if (!index) continue;
      const panes = Number.parseInt(panesStr ?? "0", 10) || 0;
      paneTotal += panes;
      const nameDecoded = b64Name ?? "";
      const commandDecoded = b64Command ?? "";
      windows.push({
        index,
        name: nameDecoded.length > 0 ? decodeTmuxString(nameDecoded) : "(unnamed)",
        panes,
        active: activeStr === "1",
        command: decodeTmuxString(commandDecoded).trim(),
      });
    }

    sessions.push({
      name,
      windows,
      totalWindows: windows.length,
      totalPanes: paneTotal,
      isCurrent: inTmux && name === currentSession,
    });
  }

  return sessions;
}

async function collectPaneInfo(target: string, recursive: boolean): Promise<PaneInfo[]> {
  const args = ["list-panes"];
  if (recursive) {
    args.push("-s");
  }
  args.push("-t", target);
  args.push("-F", "#{pane_id}\t#{pane_pid}");
  const output = await runCommand("tmux", args, { allowFail: true });
  if (!output) {
    return [];
  }

  return output
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line.length > 0)
    .map((line) => {
      const [id, pid] = line.split("\t");
      return {
        id: (id ?? "").trim(),
        pid: (pid ?? "").trim(),
      };
    })
    .filter((pane) => pane.id.length > 0);
}

interface CleanKillOptions {
  target: string;
  recursive: boolean;
  finalCommand: {
    cmd: string;
    args: string[];
  };
}

async function cleanKillTarget(options: CleanKillOptions): Promise<void> {
  const panes = await collectPaneInfo(options.target, options.recursive);
  if (panes.length === 0) {
    await runCommand(options.finalCommand.cmd, options.finalCommand.args, { allowFail: true });
    return;
  }

  const currentPane = Deno.env.get("TMUX_PANE") ?? "";
  const panesToSignal = panes.filter((pane) => pane.id !== currentPane);

  if (panesToSignal.length > 0) {
    await Promise.all(panesToSignal.map((pane) =>
      runCommand("tmux", ["send-keys", "-t", pane.id, "C-c"], { allowFail: true })
    ));
  }

  if (panesToSignal.length > 0) {
    await sleep(300);
  }

  const pgids = new Set<string>();

  for (const pane of panesToSignal) {
    const pid = pane.pid;
    if (!pid || !/^\d+$/.test(pid)) {
      continue;
    }
    const pgidOutput = (await runCommand("ps", ["-o", "pgid=", "-p", pid], { allowFail: true })).trim();
    if (!pgidOutput) {
      continue;
    }
    const normalized = pgidOutput.split(/\s+/).find((part) => part.length > 0);
    if (normalized) {
      pgids.add(normalized);
    }
  }

  if (pgids.size > 0) {
    await Promise.all(Array.from(pgids).map((pgid) =>
      runCommand("kill", ["-TERM", `-${pgid}`], { allowFail: true })
    ));
  }

  if (pgids.size > 0) {
    await sleep(300);
  }

  if (pgids.size > 0) {
    await Promise.all(Array.from(pgids).map(async (pgid) => {
      const stillRunning = (await runCommand("ps", ["-o", "pid=", "-g", pgid], { allowFail: true })).trim();
      if (stillRunning) {
        await runCommand("kill", ["-KILL", `-${pgid}`], { allowFail: true });
      }
    }));
  }

  await runCommand(options.finalCommand.cmd, options.finalCommand.args, { allowFail: true });
}

async function switchAwayFromSession(target: string): Promise<void> {
  if (!Deno.env.get("TMUX")) {
    return;
  }

  const currentSession = (await runCommand("tmux", [
    "display-message",
    "-p",
    "#{session_name}",
  ], { allowFail: true })).trim();
  if (currentSession !== target) {
    return;
  }

  const sessionsRaw = await runCommand("tmux", [
    "list-sessions",
    "-F",
    "#{session_name}",
  ], { allowFail: true });
  const names = sessionsRaw
    .split(/\r?\n/)
    .map((name) => name.trim())
    .filter((name) => name.length > 0);

  if (names.length <= 1) {
    return;
  }

  const currentIndex = names.findIndex((name) => name === target);
  const nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % names.length;
  const nextSession = names[nextIndex];

  if (!nextSession || nextSession === target) {
    return;
  }

  await runCommand("tmux", ["switch-client", "-t", nextSession], { allowFail: true });
}

async function killSessionClean(name: string): Promise<void> {
  await switchAwayFromSession(name);
  await cleanKillTarget({
    target: `${name}:`,
    recursive: true,
    finalCommand: {
      cmd: "tmux",
      args: ["kill-session", "-t", name],
    },
  });
}

async function killWindowClean(name: string): Promise<void> {
  await cleanKillTarget({
    target: name,
    recursive: false,
    finalCommand: {
      cmd: "tmux",
      args: ["kill-window", "-t", name],
    },
  });
}

async function killServerClean(): Promise<void> {
  const sessions = await collectSessions();
  const others = sessions.filter((session) => !session.isCurrent);
  for (const session of others) {
    await killSessionClean(session.name);
  }

  const current = sessions.find((session) => session.isCurrent);
  if (current) {
    await killSessionClean(current.name);
  }

  await runCommand("tmux", ["kill-server"], { allowFail: true });
}

function decodeTmuxString(value: string): string {
  // tmux can encode special characters, decode common sequences.
  if (!value) return "";
  return value
    .replace(/\\x([0-9a-fA-F]{2})/g, (_, hex) =>
      String.fromCharCode(Number.parseInt(hex, 16))
    )
    .replace(/\\([0-7]{1,3})/g, (_, oct) =>
      String.fromCharCode(Number.parseInt(oct, 8))
    )
    .replace(/\\\\/g, "\\");
}

function formatSessionDisplay(session: SessionInfo, mode: Mode): string {
  const starColor = mode === "kill" ? colors.red : colors.green;
  const marker = session.isCurrent ? starColor("*") : " ";
  const windowLabel = session.totalWindows === 1 ? "window" : "windows";
  const paneLabel = session.totalPanes === 1 ? "pane" : "panes";
  return `${marker} ${colors.bold(session.name)}  ${colors.dim("|")} ${colors.dim("windows")} ${colors.cyan(String(session.totalWindows))}  ${colors.dim("|")} ${colors.dim("panes")} ${colors.cyan(String(session.totalPanes))}`;
}

function formatWindowDisplay(
  session: SessionInfo,
  window: WindowInfo,
  isLast: boolean,
  mode: Mode,
): string {
  const branch = isLast ? "  └─" : "  ├─";
  const starColor = mode === "kill" ? colors.red : colors.green;
  const marker = window.active ? starColor("*") : " ";
  const paneLabel = window.panes === 1 ? "pane" : "panes";
  const commandLabel = window.command ? `  ${colors.dim("|")} ${colors.dim("cmd")} ${colors.magenta(window.command)}` : "";
  return `${branch} ${marker} ${colors.bold(session.name)}:${colors.cyan(window.index)} ${window.name}  ${colors.dim("|")} ${colors.dim("panes")} ${colors.cyan(String(window.panes))}${commandLabel}`;
}

function buildEntries(sessions: SessionInfo[], mode: Mode): Entry[] {
  const entries: Entry[] = [];

  for (const session of sessions) {
    entries.push({
      action: "session",
      name: session.name,
      display: formatSessionDisplay(session, mode),
    });

    session.windows.forEach((window, index) => {
      entries.push({
        action: "window",
        name: `${session.name}:${window.index}`,
        display: formatWindowDisplay(session, window, index === session.windows.length - 1, mode),
      });
    });
  }

  if (mode === "select" && !Deno.env.get("TMUX")) {
    entries.push({
      action: "create",
      name: "",
      display: `${colors.green("create")} [ ${colors.bold("new session") } | ${colors.cyan("tmux new-session")} ]`,
    });
  }

  if (mode === "kill") {
    const sessionCount = sessions.length;
    if (sessionCount > 1) {
      entries.push({
        action: "server",
        name: "",
        display: `  ${colors.red("✖")} ${colors.bold("tmux server")}  ${colors.dim("|")} ${colors.cyan("tmux kill-server")}`,
      });
    }
  }

  return entries;
}

interface RunFzfOptions {
  forcePlain?: boolean;
}

async function runFzf(
  entries: Entry[],
  mode: Mode,
  options: RunFzfOptions = {},
): Promise<string[]> {
  if (entries.length === 0) {
    return [];
  }

  const inTmux = Boolean(Deno.env.get("TMUX"));
  const useFzfTmux = !options.forcePlain && inTmux && await commandExists("fzf-tmux");
  const baseCmd = useFzfTmux ? "fzf-tmux" : "fzf";

  const commonArgs = [
    "--ansi",
    `--prompt=${mode === "kill" ? "Kill" : "Session"}> `,
    `--delimiter=${"\t"}`,
    "--with-nth=3",
    "--cycle",
    "--reverse",
    "--height=100%",
    "--no-info",
    "--no-sort",
    "--exact",
  ];

  if (mode === "kill") {
    commonArgs.push("--multi", "--bind=ctrl-a:select-all,ctrl-d:deselect-all");
  }

  const args = useFzfTmux
    ? ["-p", "50%,50%", ...commonArgs]
    : commonArgs;

  const command = new Deno.Command(baseCmd, {
    args,
    stdin: "piped",
    stdout: "piped",
    stderr: "piped",
  });

  const child = command.spawn();
  const writer = child.stdin.getWriter();
  const payload = entries.map((entry) => `${entry.action}\t${entry.name}\t${entry.display}`).join("\n");
  await writer.write(encoder.encode(payload));
  await writer.write(encoder.encode("\n"));
  await writer.close();

  const { code, stdout } = await child.output();
  if (code !== 0) {
    return [];
  }

  const text = decoder.decode(stdout).trim();
  if (!text) {
    return [];
  }
  return text.split(/\r?\n/);
}

async function handleSelection(lines: string[], mode: Mode): Promise<void> {
  if (lines.length === 0) {
    return;
  }

  if (mode === "kill") {
    for (const line of lines) {
      const [action, name] = line.split("\t");
      if (!action) continue;
      if (action === "session" && name) {
        await killSessionClean(name);
      } else if (action === "window" && name) {
        await killWindowClean(name);
      } else if (action === "server") {
        await killServerClean();
      }
    }
    return;
  }

  const [line] = lines;
  const [action, name] = line.split("\t");
  if (!action) {
    return;
  }

  if (action === "session" && name) {
    if (Deno.env.get("TMUX")) {
      await runCommand("tmux", ["switch-client", "-t", name], { allowFail: true });
    } else {
      await runCommand("tmux", ["attach", "-t", name], { allowFail: true, inheritStdio: true });
    }
  } else if (action === "window" && name) {
    const sessionName = name.split(":")[0] ?? name;
    if (Deno.env.get("TMUX")) {
      await runCommand("tmux", ["switch-client", "-t", sessionName], { allowFail: true });
      await runCommand("tmux", ["select-window", "-t", name], { allowFail: true });
    } else {
      await runCommand("tmux", ["select-window", "-t", name], { allowFail: true });
      await runCommand("tmux", ["attach", "-t", sessionName], { allowFail: true, inheritStdio: true });
    }
  } else if (action === "create") {
    await runCommand("tmux", ["new-session"], { allowFail: true, inheritStdio: true });
  }
}

async function openPopupIfNeeded(mode: Mode, popup: boolean): Promise<void> {
  if (!Deno.env.get("TMUX") || popup) {
    return;
  }

  const paneDir = (await runCommand("tmux", [
    "display-message",
    "-p",
    "#{pane_current_path}",
  ], { allowFail: true })).trim() || Deno.env.get("HOME") || Deno.cwd();

  const scriptPath = fromFileUrl(import.meta.url);
  const args = mode === "kill" ? ["--kill", "--popup"] : ["--popup"];

  try {
    const popupCmd = new Deno.Command("tmux", {
      args: [
        "display-popup",
        "-E",
        "-w",
        "50%",
        "-h",
        "50%",
        "-d",
        paneDir,
        scriptPath,
        ...args,
      ],
      stdout: "null",
      stderr: "piped",
    });
    const { code, stderr } = await popupCmd.output();
    if (code === 0) {
      Deno.exit(0);
    } else {
      const warning = decoder.decode(stderr).trim();
      if (warning.length > 0) {
        console.error(`tmux display-popup failed (${code}): ${warning}`);
      }
    }
  } catch (error) {
    console.error(`tmux display-popup not available: ${error instanceof Error ? error.message : String(error)}`);
  }
}

async function main(): Promise<void> {
  const cli = new Command()
    .name("tmux-session-manager")
    .description("tmux session selector/killer manager")
    .option("--kill", "Kill session(s) instead of selecting/attaching", { default: false })
    .option("--popup", "Internal flag to skip popup", { default: false })
    .action(async ({ kill, popup }: { kill: boolean; popup: boolean }) => {
      const mode: Mode = kill ? "kill" : "select";
      await openPopupIfNeeded(mode, popup);

      const sessions = await collectSessions();
      const entries = buildEntries(sessions, mode);
      const lines = await runFzf(entries, mode, { forcePlain: popup });
      await handleSelection(lines, mode);
    });

  await cli.parse(Deno.args);
}

if (import.meta.main) {
  await main();
}

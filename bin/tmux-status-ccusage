#!/usr/bin/env node

import { execSync } from "node:child_process";

const SESSION_DURATION_MINUTES = 5 * 60;
const COST_LIMIT_USD = 100;
const COST_RATE_THRESHOLDS = { critical: 21, warning: 14, elevated: 6 };
const COST_HIGHLIGHT_THRESHOLD = 6;
const COST_DELTA_THRESHOLD = 2;
const DEFAULT_CLAUDE_COMMAND = "ccusage";
const DEFAULT_CODEX_COMMAND = "ccusage-codex";

const argOverrides = parseCommandOverrides(process.argv.slice(2));
const CLAUDE_COMMAND =
  normalizeCommand(argOverrides.claude)
  ?? normalizeCommand(process.env.CCUSAGE_CLAUDE_CMD)
  ?? DEFAULT_CLAUDE_COMMAND;
const CODEX_COMMAND =
  normalizeCommand(argOverrides.codex)
  ?? normalizeCommand(process.env.CCUSAGE_CODEX_CMD)
  ?? DEFAULT_CODEX_COMMAND;

main();

function main() {
  const codexLine = buildSessionSummary({
    command: CODEX_COMMAND,
    label: "Codex",
    accentColor: "#[fg=magenta,bold]",
    type: "codex",
    fatalOnFailure: false,
  });

  const claudeLine = buildSessionSummary({
    command: CLAUDE_COMMAND,
    label: "Claude",
    accentColor: "#[fg=cyan,bold]",
    type: "claude",
    fatalOnFailure: true,
  });

  const parts = [];
  if (codexLine != null) {
    parts.push(codexLine);
  }
  if (claudeLine != null) {
    parts.push(claudeLine);
  }

  if (parts.length === 0) {
    process.stdout.write("#[fg=white]No active sessions");
    process.exit(0);
  }

  process.stdout.write(parts.join(" #[fg=white] "));
}

function buildSessionSummary(options) {
  const { command, label, accentColor, type, fatalOnFailure } = options;
  const result = loadSession(command);

  if (result.status === "missing") {
    if (fatalOnFailure) {
      process.exit(1);
    }
    return `${accentColor}${label}#[fg=white] CLI not found`;
  }

  if (result.status === "error") {
    if (fatalOnFailure) {
      process.exit(1);
    }
    return `${accentColor}${label}#[fg=white] unavailable`;
  }

  if (result.status === "idle") {
    return `${accentColor}${label}#[fg=white] No active session`;
  }

  if (result.status === "active") {
    const summary = formatActiveBlock(result.block, type);
    return `${accentColor}${label}#[fg=white] ${summary}`;
  }

  return null;
}

function loadSession(command) {
  const response = runBlocksCommand(command);

  if (response.type === "missing") {
    return { status: "missing" };
  }

  if (response.type === "error") {
    return { status: "error" };
  }

  const payload = response.data;
  const blocks = Array.isArray(payload?.blocks) ? payload.blocks : [];
  const activeBlock = blocks.find(block => block?.isActive === true && block?.isGap !== true);

  if (activeBlock == null) {
    return { status: "idle" };
  }

  return { status: "active", block: activeBlock };
}

function runBlocksCommand(command) {
  const fullCommand = `${command} blocks --json --offline`;

  try {
    const stdout = execSync(fullCommand, { encoding: "utf-8", stdio: ["ignore", "pipe", "pipe"] });
    const payload = extractJson(stdout);
    if (payload == null) {
      return { type: "error" };
    }
    return { type: "ok", data: payload };
  } catch (error) {
    if (error?.code === "ENOENT" || error?.status === 127) {
      return { type: "missing" };
    }

    const stderrText = bufferToString(error?.stderr) + bufferToString(error?.stdout);
    if (/not found/i.test(stderrText) || /command not found/i.test(String(error?.message ?? ""))) {
      return { type: "missing" };
    }

    return { type: "error" };
  }
}

function formatActiveBlock(block, type) {
  const totalMinutes = computeTotalMinutes(block);
  const remainingMinutes = computeRemainingMinutes(block, totalMinutes);
  const elapsedMinutes = Math.max(0, totalMinutes - remainingMinutes);
  const elapsedHours = elapsedMinutes / 60;

  const currentCost = Number.isFinite(block?.costUSD) ? block.costUSD : 0;
  const recentCostPerHour = Number.isFinite(block?.burnRate?.costPerHour) ? block.burnRate.costPerHour : 0;
  const avgCostPerHour = elapsedHours > 0 ? currentCost / elapsedHours : 0;

  const progressColor = chooseRemainingColor(remainingMinutes);
  const progressBar = buildProgressBar(remainingMinutes, totalMinutes);
  const timeColor = chooseRemainingColor(remainingMinutes);
  const timeStr = formatRemainingTime(remainingMinutes);
  const endTimeStr = formatProjectedEndTime(remainingMinutes);
  const totalCostColor = chooseTotalCostColor(currentCost);

  const segments = [
    `${progressColor}${progressBar}#[fg=white]`,
    `${timeColor}${timeStr} (~${endTimeStr})#[fg=white]`,
    `${totalCostColor}$${currentCost.toFixed(2)}#[fg=white]${formatCostHighlights({ recentCostPerHour, avgCostPerHour })}`,
  ];

  return segments.join(" | ");
}

function computeTotalMinutes(block) {
  const start = parseIsoDate(block?.startTime);
  const end = parseIsoDate(block?.endTime);
  if (start != null && end != null) {
    const diff = Math.round((end.getTime() - start.getTime()) / 60000);
    if (Number.isFinite(diff) && diff > 0) {
      return diff;
    }
  }
  return SESSION_DURATION_MINUTES;
}

function computeRemainingMinutes(block, totalMinutes) {
  const projected = Number(block?.projection?.remainingMinutes);
  if (Number.isFinite(projected)) {
    return clamp(projected, 0, totalMinutes);
  }

  const end = parseIsoDate(block?.endTime);
  if (end != null) {
    const diff = Math.round((end.getTime() - Date.now()) / 60000);
    if (Number.isFinite(diff)) {
      return clamp(diff, 0, totalMinutes);
    }
  }

  return Math.max(0, Math.min(totalMinutes, SESSION_DURATION_MINUTES));
}

function buildProgressBar(remainingMinutes, totalMinutes) {
  if (totalMinutes <= 0) {
    return "[░░░░░░░░░░]";
  }

  const percent = clamp(Math.round((remainingMinutes * 100) / totalMinutes), 0, 100);
  const filled = clamp(Math.round(percent / 10), 0, 10);
  const empty = 10 - filled;
  return `[${"█".repeat(filled)}${"░".repeat(empty)}]`;
}

function formatRemainingTime(remainingMinutes) {
  const safe = Math.max(0, Math.round(remainingMinutes));
  const hours = Math.floor(safe / 60);
  const minutes = safe % 60;
  if (hours > 0) {
    return `${hours}h${minutes.toString().padStart(2, "0")}m`;
  }
  return `${minutes}m`;
}

function formatProjectedEndTime(remainingMinutes) {
  const now = new Date();
  const endTime = new Date(now.getTime() + Math.max(0, remainingMinutes) * 60 * 1000);
  const endMinutes = endTime.getMinutes();

  if (endMinutes === 59 || endMinutes >= 58) {
    endTime.setMinutes(0);
    endTime.setHours(endTime.getHours() + 1);
  } else if (endMinutes === 0) {
    // keep as is
  }

  return endTime.toLocaleTimeString("ja-JP", {
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  });
}

function chooseRemainingColor(remainingMinutes) {
  if (remainingMinutes <= 60) {
    return "#[fg=red,bold]";
  }
  if (remainingMinutes <= 120) {
    return "#[fg=yellow,bold]";
  }
  if (remainingMinutes <= 180) {
    return "#[fg=cyan]";
  }
  return "#[fg=green]";
}

function chooseTotalCostColor(currentCost) {
  const costPercent = (currentCost / COST_LIMIT_USD) * 100;
  if (costPercent >= 80) {
    return "#[fg=red,bold]";
  }
  if (costPercent >= 60) {
    return "#[fg=yellow,bold]";
  }
  if (costPercent >= 40) {
    return "#[fg=cyan]";
  }
  return "#[fg=green]";
}

function chooseRateColor(rate) {
  if (rate >= COST_RATE_THRESHOLDS.critical) {
    return "#[fg=red,bold]";
  }
  if (rate >= COST_RATE_THRESHOLDS.warning) {
    return "#[fg=yellow]";
  }
  if (rate >= COST_RATE_THRESHOLDS.elevated) {
    return "#[fg=cyan]";
  }
  return "#[fg=green]";
}

function formatCostHighlights(rates) {
  const { recentCostPerHour, avgCostPerHour } = rates;
  const parts = [];

  if (recentCostPerHour >= COST_HIGHLIGHT_THRESHOLD) {
    parts.push(`${chooseRateColor(recentCostPerHour)}⚡$${recentCostPerHour.toFixed(1)}/h`);
  }

  if (
    avgCostPerHour >= COST_HIGHLIGHT_THRESHOLD &&
    Math.abs(avgCostPerHour - recentCostPerHour) >= COST_DELTA_THRESHOLD
  ) {
    parts.push(`${chooseRateColor(avgCostPerHour)}⌀ $${avgCostPerHour.toFixed(1)}/h`);
  }

  if (parts.length === 0) {
    return "";
  }

  return " " + parts.map(part => `${part}#[fg=white]`).join(" ");
}

function parseIsoDate(value) {
  if (typeof value !== "string") {
    return null;
  }
  const date = new Date(value);
  return Number.isNaN(date.getTime()) ? null : date;
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

function bufferToString(buffer) {
  if (buffer == null) {
    return "";
  }
  if (Buffer.isBuffer(buffer)) {
    return buffer.toString("utf-8");
  }
  if (typeof buffer === "string") {
    return buffer;
  }
  return "";
}

function parseCommandOverrides(argv) {
  const overrides = { codex: null, claude: null };
  const positional = [];

  for (let index = 0; index < argv.length; index += 1) {
    const token = argv[index];
    if (token === "--codex" && argv[index + 1] != null) {
      overrides.codex = argv[index + 1];
      index += 1;
      continue;
    }
    if (token?.startsWith("--codex=")) {
      overrides.codex = token.slice("--codex=".length);
      continue;
    }
    if (token === "--claude" && argv[index + 1] != null) {
      overrides.claude = argv[index + 1];
      index += 1;
      continue;
    }
    if (token?.startsWith("--claude=")) {
      overrides.claude = token.slice("--claude=".length);
      continue;
    }
    positional.push(token);
  }

  if (overrides.codex == null && positional.length > 0) {
    overrides.codex = positional.shift() ?? null;
  }
  if (overrides.claude == null && positional.length > 0) {
    overrides.claude = positional.shift() ?? null;
  }

  return overrides;
}

function normalizeCommand(value) {
  if (typeof value !== "string") {
    return null;
  }
  const trimmed = value.trim();
  return trimmed.length === 0 ? null : trimmed;
}

function extractJson(output) {
  if (typeof output !== "string" || output.length === 0) {
    return null;
  }

  const start = output.indexOf("{");
  const end = output.lastIndexOf("}");
  if (start === -1 || end === -1 || end < start) {
    return null;
  }

  const candidate = output.slice(start, end + 1);
  try {
    return JSON.parse(candidate);
  } catch {
    return null;
  }
}

---
description: Analyze git changes and create an organized commit plan with logical grouping
---

# コミット計画作成: $ARGUMENTS

## 目標

現在のGit変更を分析し、論理的にグループ化された整理されたコミット計画を作成する

## ARGUMENTSの活用

`$ARGUMENTS`は以下のような用途で使用する：

### 1. 特定のパスやパターンに限定
```bash
/commit-plan "src/"  # srcディレクトリの変更のみ対象
/commit-plan "*.ts"  # TypeScriptファイルのみ対象
/commit-plan "frontend/ backend/"  # 複数ディレクトリを指定
```

### 2. コミット戦略の指定
```bash
/commit-plan "細かく分割"  # より詳細な分割を要求
/commit-plan "機能ごとにまとめる"  # 機能単位でグループ化
/commit-plan "ファイルタイプ別"  # 拡張子でグループ化
```

### 3. 実行モードの事前指定
```bash
/commit-plan "--auto"  # 自動実行モード
/commit-plan "--dry-run"  # ドライランモード
/commit-plan "--interactive"  # インタラクティブモード
```

### 4. 特定の要件やコンテキスト
```bash
/commit-plan "PRレビュー用に整理"  # レビューしやすい単位で分割
/commit-plan "リリースノート生成を考慮"  # リリースノートに記載しやすい形式
/commit-plan "依存関係を重視"  # ビルドが壊れない順序を優先
```

## 実行手順

### ステップ 1: 現在の状態を分析
```bash
# 並行実行で情報収集
git status --porcelain
git diff --cached --stat
git diff --stat
git log --oneline -20  # 過去のコミットメッセージフォーマットを参考にする

# ARGUMENTSに基づいた処理
if [ -n "$ARGUMENTS" ]; then
    # パスパターンの場合: 指定されたパスのファイルのみを対象
    # 例: "src/" → src/配下の変更のみ
    # 例: "*.ts" → TypeScriptファイルのみ

    # 戦略指定の場合: コミット分割の方針を決定
    # 例: "細かく分割" → より小さな単位でコミット
    # 例: "ファイルタイプ別" → 拡張子ごとにグループ化

    # モード指定の場合: デフォルトの実行モードを設定
    # 例: "--auto" → 選択プロンプトをスキップ
fi
```

### ステップ 2: 過去のコミットパターン分析

**重要**: プロジェクトの過去のコミットメッセージを分析して、以下を確認する：
- 使用されているプレフィックス（feat/fix/docs等）の傾向
- 日本語/英語の使い分けルール
- メッセージの長さや詳細度
- 箇条書きの使用有無
- スコープの記載方法（例: `feat(cli):` vs `feat:`）

### ステップ 3: 変更の分類と関連性分析

1. **ファイルタイプ別分類**
   - ソースコード（.ts, .js, .py等）
   - 設定ファイル（.json, .yaml, .toml等）
   - ドキュメント（.md, .txt等）
   - テストファイル（test/spec含む）

2. **ディレクトリ構造による関連性**
   - 同一ディレクトリ内の変更
   - 関連するコンポーネント（例: componentとそのtest）
   - 依存関係のあるファイル

3. **変更内容による分類**
   - feat: 新機能
   - fix: バグ修正
   - docs: ドキュメントのみ
   - style: フォーマット変更
   - refactor: リファクタリング
   - test: テスト追加・修正
   - chore: その他の変更

### ステップ 4: コミット計画の作成

**注意**: コミットメッセージは過去のログから抽出したパターンに従って作成する

以下の形式で番号付きのコミット計画を出力する：

```markdown
## 📋 コミット計画

### [1] feat: 新機能の追加
**ファイル**: 
- `path/to/feature.ts` (新規)
- `path/to/feature.test.ts` (新規)

**メッセージ案**:
```
feat: Add new feature for handling user preferences

- Implement preference storage module  
- Add unit tests
```

### [2] fix: バグ修正
**ファイル**:
- `path/to/bugfix.ts` (修正)

（以下、必要なコミット数だけ続く）

## 📊 サマリー
- 総変更ファイル数: X個
- 推奨コミット数: Y個
- 依存関係: [1]を先に実行
```

### ステップ 5: 実行方法の選択提示

**ユーザーに以下の選択肢を提示する：**

```
💡 実行方法を選択してください:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[a] すべて自動実行 - 計画通りに全コミットを実行
[i] インタラクティブ - 各コミット前に確認
[e] 計画を編集 - 計画の修正や調整
[d] ドライラン - 実際のコミットは行わず確認のみ
[s] スクリプトとして保存 - 後で実行するためのスクリプト生成
[q] キャンセル - 計画を破棄

選択: 
```

### ステップ 6: 選択に応じた実行

#### [a] 自動実行の場合
- すべてのコミットを順番に実行
- 各コミット後にgit statusで確認
- エラー発生時:
  - 実行を停止
  - エラー内容を表示
  - 既に実行済みのコミットをリスト表示
  - リカバリー方法を提案

#### [i] インタラクティブの場合
- 各コミット前に変更内容を表示（git diff）
- 選択肢を提示:
  - [y] 実行
  - [n] スキップ
  - [e] メッセージ編集
  - [q] 中断
- エラー時は自動的に停止し、状況を報告

#### [e] 計画編集の場合
**実装方法**：
1. 現在の計画を番号付きリストで表示
2. 以下の編集コマンドを対話的に受け付ける：

**編集コマンド例**：
```
統合: "1,2を統合" または "merge 1 2"
分割: "3を分割" または "split 3"
順序変更: "1と3を入れ替え" または "swap 1 3"
メッセージ変更: "2のメッセージ: 新しいメッセージ内容"
ファイル移動: "file.txtを2から3へ" または "move file.txt from 2 to 3"
削除: "4を削除" または "delete 4"
完了: "完了" または "done"
```

**編集フロー**：
1. 計画を表示
2. 編集コマンドを入力
3. 変更後の計画を再表示
4. 追加の編集または完了を選択
5. 完了後、実行方法の選択画面に戻る

#### [d] ドライランの場合
- 実行予定のコマンドを表示のみ
- 実際のgit操作は行わない
- 最終確認用

#### [s] スクリプト保存の場合
```bash
#!/bin/bash
# コミット計画実行スクリプト
# 生成日時: $(date)

# コミット 1
git add path/to/files...
git commit -m "feat: ..."

# コミット 2
git add path/to/other/files...
git commit -m "fix: ..."
```
- 実行可能なシェルスクリプトとして保存
- 保存先: カレントディレクトリ
- ファイル名: `commit-plan-YYYY-MM-DD-HHmmss.sh`
- 実行権限を自動付与: `chmod +x`

### ステップ 7: 実行結果の報告

選択された実行方法に応じて結果を報告：
- 自動実行/インタラクティブ: 成功したコミット数とハッシュ
- ドライラン: 実行予定だったコマンドの確認
- スクリプト保存: 保存先パスと実行方法
- エラー発生時: 具体的なエラー内容と対処法

### ステップ 8: 計画の保存（オプション）

実行完了後、必要に応じて計画と結果を保存：
```bash
# ai/plans/active/ に計画を保存
echo "$COMMIT_PLAN" > "ai/plans/active/$(date +%Y-%m-%d)-commit-plan.md"
```

## 注意事項

- **依存関係の考慮**: ビルドが壊れないような順序で計画
- **コミットサイズ**: 1つのコミットは1つの論理的変更に限定
- **メッセージ規約**: プロジェクトの過去のコミットパターンを優先し、Conventional Commitsを補助的に使用
- **一貫性の維持**: 過去のコミットメッセージのスタイルと整合性を保つ
- **レビューの容易さ**: レビュアーが理解しやすい単位で分割

## 高度なオプション

- `--auto`: 選択プロンプトをスキップして自動実行
- `--interactive`: デフォルトでインタラクティブモードを選択
- `--dry-run`: デフォルトでドライランモードを選択
- `--squash-related`: 関連する小さな変更をまとめる
- `--split-large`: 大きな変更を自動分割

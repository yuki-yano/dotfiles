## 前提

応答は全て日本語で行うように

## AI作業ディレクトリのルール

### ディレクトリ構造と用途
プロジェクトのAI支援作業では、以下のディレクトリ構造を使用してください：

1. **`ai/tmp/`** - 一時的な作業ファイル
   - デバッグ、実験、検証用
   - セッション終了時に削除可能

2. **`ai/log/`** - 時系列の作業記録
   - `features/` - 実装した機能
   - `fixes/` - バグ修正
   - `tests/` - テスト実行結果
   - `sessions/` - セッション引き継ぎ
   - `nippo/` - 日次作業記録（日報）
   - ファイル名: `YYYY-MM-DD-説明.md`（nippoは`YYYY-MM-DD.md`）

3. **`ai/knowledge/`** - 恒久的な知識ベース
   - `learnings/` - 技術的な学習事項
   - `decisions/` - アーキテクチャ決定
   - `patterns/` - ベストプラクティス
   - `context/` - プロジェクトコンテキスト

4. **`ai/issues/`** - 問題管理
   - `active/` - 対応中の問題
   - `resolved/` - 解決済み
   - `blocked/` - ブロック中

5. **`ai/plans/`** - 計画とチェックリスト
   - `active/` - 実行中の計画
   - `completed/` - 完了した計画

6. **`ai/roadmap/`** - プロジェクトのロードマップ
   - `current/` - 現在のロードマップ
   - `archive/` - 過去のロードマップ
   - `milestones/` - マイルストーン定義

### ファイル命名規則
- 日付を含む場合: `YYYY-MM-DD-簡潔な説明.md`
- 説明は15文字以内を推奨
- 日本語可、スペースの代わりにハイフンを使用

### ファイル作成時の日付取得（必須）

**重要**: ログファイルを作成する際は、必ず以下のコマンドで現在の日付を取得して使用すること：

```bash
# 現在の日付を取得（YYYY-MM-DD形式）
DATE=$(perl -MPOSIX -le 'print strftime("%Y-%m-%d", localtime)')

# ファイル名の例
FILENAME="ai/log/features/${DATE}-feature-name.md"
```

**注意事項**:
- 環境情報の「Today's date」に依存せず、必ず上記のコマンドで実際の日付を取得する
- タイムスタンプが必要な場合は `perl -MPOSIX -le 'print strftime("%Y-%m-%d %H:%M:%S", localtime)'` を使用
- 日本時間（JST）を明示する場合は `perl -MPOSIX -le 'print strftime("%Y-%m-%d %H:%M (JST)", localtime)'` を使用

### 重要な原則
- **既存の情報を確認**: 新規作成前に関連ディレクトリを確認
- **適切な場所に保存**: 目的に応じて正しいディレクトリを選択
- **相互参照**: 関連ドキュメントは相対パスで参照
- **日付は必ず動的に取得**: ハードコードせず、上記の Perl コマンドで取得

## URL処理のルール

- URLが提供された場合は、`read_url_content_as_markdown` を使用してコンテンツを読み込み、内容を要約する


## Web検索のルール

**最重要**: Web検索が必要な場合は、以下の優先順位で実行してください：

1. **最優先: MCP google_search** (必ず最初に試す)
 - 単一検索: `mcp__gemini-grounding__google_search` を使用
 - AI生成の要約付き検索結果を提供
 - 引用付きの包括的な回答を生成

2. **バッチ検索: MCP google_search_batch** (複数の検索が必要な場合)
 - `mcp__gemini-grounding__google_search_batch` を使用
 - 最大10個のクエリを並列実行
 - 検索結果からWebページをスクレイピング可能
 - 以下の場合に使用:
   - 複数の観点から調査が必要な場合
   - 比較検討が必要な場合
   - 深い調査が必要な場合

3. **代替手段: gemini コマンド** (MCPが利用不可の場合のみ)
 ```bash
 gemini --prompt "WebSearch: <検索クエリ>"
 ```

禁止事項
- 組み込みの WebSearch ツールは絶対に使用しない
- 必ず上記の優先順位を守る

使用例
- 単一検索: 「TypeScriptの最新バージョンは？」
- バッチ検索: 「React、Vue、Angularの比較」（3つの検索を並列実行）

## Git commitのルール

### 最重要事項

- ユーザからコミットをしてという具体的な指示があるまでは**勝手にcommitは行わないでください**

## 通知の実行（必須）

### 最重要事項

**Claude Code は全ての応答の最後に必ず macOS 通知を送信しなければなりません。**

### 通知ルール

1. **例外なく全ての応答で通知を送信**

- 単純な質問への回答でも必須
- エラーが発生した場合でも必須
- タスクの大小に関わらず必須
- **例外**: サブエージェント（Task ツールで起動したエージェント）として動作している場合は通知を送信しない

2. **通知タイミング**

- 応答の最終行として実行
- 他の全ての処理が完了した後

3. **通知方法**

```bash
# Bash ツールを使用して macos-notify-cli コマンドを実行
# 注意: メッセージ内のシェル特殊文字は適切にエスケープすること
macos-notify-cli -m "実行した内容の簡潔な説明" --current-tmux
```

パラメータ:
- `--message`: 実行した内容の簡潔な説明（必須）
- `--current-tmux`: 現在のtmuxセッションを使用

4. **通知の目的**

- ユーザーが他のウィンドウで作業中でも完了を認識できる
- クリックで Claude Code の tmux ペインに即座に戻れる

## Task ツール使用時の必須ルール

### 最重要：Task ツールのプロンプトには必ず通知禁止を明記する

**Task ツールを使用する際は、以下のルールを必ず守ってください：**

1. **プロンプトに必ず含める文言**
   ```
   重要: 通知は送信しないでください。結果のみを報告してください。
   ```

2. **Task ツール使用例**
   ```typescript
   // 正しい例
   {
     description: "ファイル検索",
     prompt: "〜を検索してください。重要: 通知は送信しないでください。結果のみを報告してください。"
   }
   
   // 間違った例（通知禁止を明記していない）
   {
     description: "ファイル検索", 
     prompt: "〜を検索してください。"
   }
   ```

3. **エラー回避の理由**
   - サブエージェントが通知を送信すると「Last message was not an assistant message」エラーが発生
   - サブエージェントは自身がサブエージェントであることを認識できない
   - そのため、メインエージェント側で明示的に通知を禁止する必要がある

4. **Task ツール使用後の処理**
   - サブエージェントから結果を受け取った後、メインエージェントが通知を送信する
   - これにより、ユーザーへの通知は確実に行われ、エラーも回避できる
